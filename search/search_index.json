{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Umlet Utils","text":"<p>Utilities for generating Umlet use case- and class diagrams.</p>"},{"location":"#commands","title":"Commands","text":"<p>The following exported console scripts are available:</p> <ul> <li>umlet-utils-python-api-to-umlet-class-diagram</li> <li>umlet-utils-survey-python-codebase</li> <li>umlet-utils-yaml-to-use-case</li> </ul>"},{"location":"#references","title":"References","text":"<ul> <li>GitHub</li> <li>PYPI</li> </ul>"},{"location":"CHANGELOG/","title":"CHANGELOG","text":""},{"location":"CHANGELOG/#v010-2024-02-01","title":"v0.1.0 - 2024-02-01","text":"<p>ADDS: - umlet-utils-python-api-to-umlet-class-diagram - umlet-utils-survey-python-codebase - umlet-utils-yaml-to-use-case</p>"},{"location":"INSTALL/","title":"INSTALL","text":""},{"location":"INSTALL/#install-from-pypi","title":"Install from PYPI","text":"<p>Install the package in your Python virtual environment</p> <pre><code>source venv/bin/activate\npip install umlet-utils\n</code></pre>"},{"location":"INSTALL/#clone-project","title":"Clone project","text":"<p>You can <code>git clone</code> this project.</p> <pre><code>git clone https://github.com/jai-python3/umlet-utils.git\ncd umlet-utils\n</code></pre>"},{"location":"INSTALL/#local-pip-install","title":"Local pip install","text":"<p>You can optionally establish a Python virtual environment. Then you can run the <code>setup.py</code> script to build to project and then run <code>pip install</code> to install in your local Python virtual environment.</p> <pre><code>virtualenv -p python3 venv\nsource venv/bin/activate\npython setup.py sdist\npip install .\n</code></pre>"},{"location":"INSTALL/#uninstall","title":"Uninstall","text":"<p>You can uninstall like this:</p> <pre><code>source venv/bin/activate\npip uninstall umlet-utils\nmake clean\n</code></pre>"},{"location":"INSTALL/#developers","title":"Developers","text":"<p>If you modify the code in this package in your local virtual environment:</p> <pre><code>pip uninstall umlet-utils\nmake clean\npython setup.py sdist\npip install .\n</code></pre>"},{"location":"INSTALL/#publish-to-pypi","title":"Publish to PYPI","text":"<p>You want can publish the code in this package to the PYPI repository.</p>"},{"location":"INSTALL/#install-twine-and-setuptools","title":"Install twine and setuptools","text":"<p>Install <code>twine</code> and <code>setuptools</code>.</p> <pre><code>pip install twine setuptools\n</code></pre>"},{"location":"INSTALL/#build-the-distribution-package","title":"Build the Distribution Package","text":"<pre><code>python setup.py sdist bdist_wheel\n</code></pre>"},{"location":"INSTALL/#configure-your-pypirc","title":"Configure your ~/.pypirc:","text":"<pre><code>[pypi]\n  username = __token__\n  password = pypi-YOUR-TOKEN\n</code></pre>"},{"location":"INSTALL/#upload-your-package-to-pypi","title":"Upload Your Package to PyPI","text":"<pre><code>twine upload dist/*\n</code></pre>"},{"location":"TODO/","title":"TODO","text":"<ul> <li>Implement unit tests (pytest)</li> <li>Add Class diagram</li> </ul>"},{"location":"make_shell_scripts_and_aliases/","title":"Make Shell Scripts And Aliases module","text":""},{"location":"make_shell_scripts_and_aliases/#umlet_utils.make_shell_scripts_and_aliases.create_aliases_file","title":"<code>create_aliases_file(wrapper_scripts, outdir, prefix=DEFAULT_ALIAS_PREFIX)</code>","text":"<p>Create a file with aliases for the wrapper scripts.</p> <p>Parameters:</p> Name Type Description Default <code>wrapper_scripts</code> <code>List[str]</code> <p>list of wrapper scripts</p> required <code>outdir</code> <code>str</code> <p>output directory</p> required Source code in <code>umlet_utils/make_shell_scripts_and_aliases.py</code> <pre><code>def create_aliases_file(wrapper_scripts: List[str], outdir: str, prefix: str = DEFAULT_ALIAS_PREFIX) -&gt; None:\n    \"\"\"Create a file with aliases for the wrapper scripts.\n\n    Args:\n        wrapper_scripts (List[str]): list of wrapper scripts\n        outdir (str): output directory\n    \"\"\"\n    outfile = os.path.join(outdir, f\"{DEFAULT_PROJECT}-aliases.txt\")\n\n    with open(outfile, 'w') as of:\n        of.write(f\"## method-created: {os.path.abspath(__file__)}\\n\")\n        of.write(f\"## date-created: {str(datetime.today().strftime('%Y-%m-%d-%H%M%S'))}\\n\")\n        of.write(f\"## created-by: {os.environ.get('USER')}\\n\")\n        for wrapper_script in wrapper_scripts:\n            alias = os.path.basename(wrapper_script).replace(\".sh\", \"\")\n            line = f\"alias {prefix}-{alias}='bash {wrapper_script}'\"\n            of.write(f\"{line}\\n\")\n\n    print(f\"Wrote aliases file '{outfile}'\")\n</code></pre>"},{"location":"make_shell_scripts_and_aliases/#umlet_utils.make_shell_scripts_and_aliases.main","title":"<code>main(alias_prefix)</code>","text":"<p>Create wrapper shell scripts and aliases.</p> Source code in <code>umlet_utils/make_shell_scripts_and_aliases.py</code> <pre><code>@click.command()\n@click.option(\n    \"--alias-prefix\",\n    type=str,\n    help=f\"Optional: The prefix to be applied to the aliases - default is '{DEFAULT_ALIAS_PREFIX}'\",\n)\ndef main(alias_prefix: str):\n    \"\"\"Create wrapper shell scripts and aliases.\"\"\"\n    error_ctr = 0\n\n    if error_ctr &gt; 0:\n        click.echo(click.get_current_context().get_help())\n        sys.exit(1)\n\n    if alias_prefix is None:\n        alias_prefix = DEFAULT_ALIAS_PREFIX\n        console.print(f\"[bold yellow]--alias-prefix was not specified and therefore was set to '{alias_prefix}'[/]\")\n\n    wrapper_scripts = []\n\n    # Directory where the wrapper scripts will be created\n    wrapper_scripts_dir = os.getcwd()\n    make_script_dir = os.path.dirname(__file__)\n\n    activate_script = os.path.join(\n        make_script_dir,\n        \"..\",\n        \"..\",\n        \"..\",\n        \"..\",\n        \"bin\",\n        \"activate\"\n    )\n\n    if not os.path.exists(activate_script):\n        raise Exception(f\"Activate script '{activate_script}' does not exist\")\n    print(f\"activate_script: {activate_script}\")\n\n    for executable in EXECUTABLES:\n        wrapper_script = create_wrapper_script(executable, activate_script, wrapper_scripts_dir)\n        wrapper_scripts.append(wrapper_script)\n\n    create_aliases_file(wrapper_scripts, os.getcwd(), alias_prefix)\n\n    console.print(f\"[bold green]Execution of {os.path.abspath(__file__)} completed[/]\")\n</code></pre>"},{"location":"python_api_to_umlet/","title":"Python Api To Umlet module","text":""},{"location":"python_api_to_umlet/#umlet_utils.python_api_to_umlet.main","title":"<code>main(indir, logfile, outdir, outfile, verbose)</code>","text":"<p>Get table counts from Redshift.</p> Source code in <code>umlet_utils/python_api_to_umlet.py</code> <pre><code>@click.command()\n@click.option(\"--indir\", help=\"The directory contain Python .py class files\")\n@click.option(\"--logfile\", help=\"The log file\")\n@click.option(\n    \"--outdir\",\n    help=f\"The default is the current working directory - default is '{DEFAULT_OUTDIR}'\",\n)\n@click.option(\"--outfile\", help=\"The output final report file\")\n@click.option(\n    \"--verbose\",\n    is_flag=True,\n    help=f\"Will print more info to STDOUT - default is '{DEFAULT_VERBOSE}'\",\n)\ndef main(indir: str, logfile: str, outdir: str, outfile: str, verbose: bool):\n    \"\"\"Get table counts from Redshift.\"\"\"\n\n    error_ctr = 0\n\n    if error_ctr &gt; 0:\n        sys.exit(1)\n\n    if indir is None:\n        indir = os.path.abspath(os.getcwd())\n        print_yellow(\n            f\"--indir was not specified and therefore was set to default '{indir}'\"\n        )\n\n    if outdir is None:\n        outdir = DEFAULT_OUTDIR\n        print_yellow(f\"--outdir was not specified and therefore was set to '{outdir}'\")\n\n    if not os.path.exists(outdir):\n        pathlib.Path(outdir).mkdir(parents=True, exist_ok=True)\n        print_yellow(f\"Created output directory '{outdir}'\")\n\n    if outfile is None:\n        outfile = os.path.join(\n            outdir, os.path.splitext(os.path.basename(__file__))[0] + \".uxf\"\n        )\n        print_yellow(\n            f\"--outfile was not specified and therefore was set to '{outfile}'\"\n        )\n\n    if logfile is None:\n        logfile = os.path.join(\n            outdir, os.path.splitext(os.path.basename(__file__))[0] + \".log\"\n        )\n        print_yellow(\n            f\"--logfile was not specified and therefore was set to '{logfile}'\"\n        )\n\n    logging.basicConfig(filename=logfile, format=LOGGING_FORMAT, level=LOG_LEVEL)\n\n    classes_only_outfile = outfile\n    outfile = outfile.replace(\".uxf\", f\"_{TIMESTAMP}.uxf\")\n    classes_only_outfile = classes_only_outfile.replace(\n        \".uxf\", f\"_classes_only_{TIMESTAMP}.uxf\"\n    )\n\n    converter = Converter(\n        indir=indir,\n        outdir=outdir,\n        outfile=outfile,\n        classes_only_outfile=classes_only_outfile,\n        logfile=logfile,\n        verbose=verbose,\n    )\n\n    converter.run()\n\n    print(f\"The log file is '{logfile}'\")\n    print_green(f\"Execution of {os.path.abspath(__file__)} completed\")\n</code></pre>"},{"location":"python_api_to_umlet/#umlet_utils.python_api_to_umlet.print_green","title":"<code>print_green(msg=None)</code>","text":"<p>Print message to STDOUT in yellow text.</p> <p>:param msg: {str} - the message to be printed</p> Source code in <code>umlet_utils/python_api_to_umlet.py</code> <pre><code>def print_green(msg: str = None) -&gt; None:\n    \"\"\"Print message to STDOUT in yellow text.\n\n    :param msg: {str} - the message to be printed\n    \"\"\"\n    if msg is None:\n        raise Exception(\"msg was not defined\")\n\n    print(Fore.GREEN + msg + Style.RESET_ALL)\n</code></pre>"},{"location":"python_api_to_umlet/#umlet_utils.python_api_to_umlet.print_yellow","title":"<code>print_yellow(msg=None)</code>","text":"<p>Print message to STDOUT in yellow text.</p> <p>:param msg: {str} - the message to be printed</p> Source code in <code>umlet_utils/python_api_to_umlet.py</code> <pre><code>def print_yellow(msg: str = None) -&gt; None:\n    \"\"\"Print message to STDOUT in yellow text.\n\n    :param msg: {str} - the message to be printed\n    \"\"\"\n    if msg is None:\n        raise Exception(\"msg was not defined\")\n\n    print(Fore.YELLOW + msg + Style.RESET_ALL)\n</code></pre>"},{"location":"survey_python_code_base/","title":"Survey Python Code Base module","text":"<p>Survey a Python code base and tally metrics.</p>"},{"location":"survey_python_code_base/#umlet_utils.survey_python_code_base.main","title":"<code>main(indir, logfile, outdir, outfile, verbose)</code>","text":"<p>Survey a Python code base and tally metrics.</p> Source code in <code>umlet_utils/survey_python_code_base.py</code> <pre><code>@click.command()\n@click.option(\"--indir\", help=\"The directory contain Python .py class files\")\n@click.option(\"--logfile\", help=\"The log file\")\n@click.option(\n    \"--outdir\",\n    help=f\"The default is the current working directory - default is '{DEFAULT_OUTDIR}'\",\n)\n@click.option(\"--outfile\", help=\"The output final report file\")\n@click.option(\n    \"--verbose\",\n    is_flag=True,\n    help=f\"Will print more info to STDOUT - default is '{DEFAULT_VERBOSE}'\",\n)\ndef main(indir: str, logfile: str, outdir: str, outfile: str, verbose: bool):\n    \"\"\"Survey a Python code base and tally metrics.\"\"\"\n\n    error_ctr = 0\n\n    if error_ctr &gt; 0:\n        sys.exit(1)\n\n    if indir is None:\n        indir = os.path.abspath(os.getcwd())\n        print_yellow(\n            f\"--indir was not specified and therefore was set to default '{indir}'\"\n        )\n\n    if outdir is None:\n        outdir = DEFAULT_OUTDIR\n        print_yellow(f\"--outdir was not specified and therefore was set to '{outdir}'\")\n\n    if not os.path.exists(outdir):\n        pathlib.Path(outdir).mkdir(parents=True, exist_ok=True)\n        print_yellow(f\"Created output directory '{outdir}'\")\n\n    if outfile is None:\n        outfile = os.path.join(\n            outdir, os.path.splitext(os.path.basename(__file__))[0] + \".txt\"\n        )\n        print_yellow(\n            f\"--outfile was not specified and therefore was set to '{outfile}'\"\n        )\n\n    if logfile is None:\n        logfile = os.path.join(\n            outdir, os.path.splitext(os.path.basename(__file__))[0] + \".log\"\n        )\n        print_yellow(\n            f\"--logfile was not specified and therefore was set to '{logfile}'\"\n        )\n\n    logging.basicConfig(filename=logfile, format=LOGGING_FORMAT, level=LOG_LEVEL)\n\n    surveyor = Surveyor(\n        indir=indir,\n        outdir=outdir,\n        outfile=outfile,\n        logfile=logfile,\n        verbose=verbose,\n    )\n\n    surveyor.run()\n\n    print(f\"The log file is '{logfile}'\")\n    print_green(f\"Execution of {os.path.abspath(__file__)} completed\")\n</code></pre>"},{"location":"survey_python_code_base/#umlet_utils.survey_python_code_base.print_green","title":"<code>print_green(msg=None)</code>","text":"<p>Print message to STDOUT in yellow text.</p> <p>:param msg: {str} - the message to be printed</p> Source code in <code>umlet_utils/survey_python_code_base.py</code> <pre><code>def print_green(msg: Union[str, None] = None) -&gt; None:\n    \"\"\"Print message to STDOUT in yellow text.\n\n    :param msg: {str} - the message to be printed\n    \"\"\"\n    if msg is None:\n        raise Exception(\"msg was not defined\")\n\n    print(Fore.GREEN + msg + Style.RESET_ALL)\n</code></pre>"},{"location":"survey_python_code_base/#umlet_utils.survey_python_code_base.print_yellow","title":"<code>print_yellow(msg=None)</code>","text":"<p>Print message to STDOUT in yellow text.</p> <p>:param msg: {str} - the message to be printed</p> Source code in <code>umlet_utils/survey_python_code_base.py</code> <pre><code>def print_yellow(msg: Union[str, None] = None) -&gt; None:\n    \"\"\"Print message to STDOUT in yellow text.\n\n    :param msg: {str} - the message to be printed\n    \"\"\"\n    if msg is None:\n        raise Exception(\"msg was not defined\")\n\n    print(Fore.YELLOW + msg + Style.RESET_ALL)\n</code></pre>"},{"location":"yaml_to_umlet_use_case/","title":"Yaml To Umlet Use Case module","text":"<p>Convert contents in YAML file to Umlet Use Case diagram.</p>"},{"location":"yaml_to_umlet_use_case/#umlet_utils.yaml_to_umlet_use_case.main","title":"<code>main(infile, logfile, outdir, outfile, verbose)</code>","text":"<p>Convert contents in YAML file to Umlet Use Case diagram.</p> Source code in <code>umlet_utils/yaml_to_umlet_use_case.py</code> <pre><code>@click.command()\n@click.option(\"--infile\", help=\"The input YAML file\")\n@click.option(\"--logfile\", help=\"The log file\")\n@click.option(\n    \"--outdir\",\n    help=f\"The default is the current working directory - default is '{DEFAULT_OUTDIR}'\",\n)\n@click.option(\"--outfile\", help=\"The output final report file\")\n@click.option(\n    \"--verbose\",\n    is_flag=True,\n    help=f\"Will print more info to STDOUT - default is '{DEFAULT_VERBOSE}'\",\n)\ndef main(infile: str, logfile: str, outdir: str, outfile: str, verbose: bool):\n    \"\"\"Convert contents in YAML file to Umlet Use Case diagram.\"\"\"\n\n    error_ctr = 0\n\n    if infile is None:\n        print_red(\"--infile was not specified\")\n        error_ctr += 1\n\n    if error_ctr &gt; 0:\n        sys.exit(1)\n\n    check_infile_status(infile)\n\n    if outdir is None:\n        outdir = DEFAULT_OUTDIR\n        print_yellow(f\"--outdir was not specified and therefore was set to '{outdir}'\")\n\n    if not os.path.exists(outdir):\n        pathlib.Path(outdir).mkdir(parents=True, exist_ok=True)\n        print_yellow(f\"Created output directory '{outdir}'\")\n\n    if outfile is None:\n        outfile = os.path.join(\n            outdir, os.path.splitext(os.path.basename(__file__))[0] + \".uxf\"\n        )\n        print_yellow(\n            f\"--outfile was not specified and therefore was set to '{outfile}'\"\n        )\n\n    if logfile is None:\n        logfile = os.path.join(\n            outdir, os.path.splitext(os.path.basename(__file__))[0] + \".log\"\n        )\n        print_yellow(\n            f\"--logfile was not specified and therefore was set to '{logfile}'\"\n        )\n\n    logging.basicConfig(filename=logfile, format=LOGGING_FORMAT, level=LOG_LEVEL)\n\n    outfile = outfile.replace(\".uxf\", f\"_{TIMESTAMP}.uxf\")\n\n    converter = Converter(\n        infile=infile,\n        outdir=outdir,\n        outfile=outfile,\n        logfile=logfile,\n        verbose=verbose,\n    )\n\n    converter.run()\n\n    print(f\"The log file is '{logfile}'\")\n    print_green(f\"Execution of {os.path.abspath(__file__)} completed\")\n</code></pre>"},{"location":"yaml_to_umlet_use_case/#umlet_utils.yaml_to_umlet_use_case.print_green","title":"<code>print_green(msg=None)</code>","text":"<p>Print message to STDOUT in yellow text.</p> <p>:param msg: {str} - the message to be printed</p> Source code in <code>umlet_utils/yaml_to_umlet_use_case.py</code> <pre><code>def print_green(msg: str = None) -&gt; None:\n    \"\"\"Print message to STDOUT in yellow text.\n\n    :param msg: {str} - the message to be printed\n    \"\"\"\n    if msg is None:\n        raise Exception(\"msg was not defined\")\n\n    print(Fore.GREEN + msg + Style.RESET_ALL)\n</code></pre>"},{"location":"yaml_to_umlet_use_case/#umlet_utils.yaml_to_umlet_use_case.print_red","title":"<code>print_red(msg=None)</code>","text":"<p>Print message to STDOUT in yellow text.</p> <p>:param msg: {str} - the message to be printed</p> Source code in <code>umlet_utils/yaml_to_umlet_use_case.py</code> <pre><code>def print_red(msg: str = None) -&gt; None:\n    \"\"\"Print message to STDOUT in yellow text.\n\n    :param msg: {str} - the message to be printed\n    \"\"\"\n    if msg is None:\n        raise Exception(\"msg was not defined\")\n\n    print(Fore.RED + msg + Style.RESET_ALL)\n</code></pre>"},{"location":"yaml_to_umlet_use_case/#umlet_utils.yaml_to_umlet_use_case.print_yellow","title":"<code>print_yellow(msg=None)</code>","text":"<p>Print message to STDOUT in yellow text.</p> <p>:param msg: {str} - the message to be printed</p> Source code in <code>umlet_utils/yaml_to_umlet_use_case.py</code> <pre><code>def print_yellow(msg: str = None) -&gt; None:\n    \"\"\"Print message to STDOUT in yellow text.\n\n    :param msg: {str} - the message to be printed\n    \"\"\"\n    if msg is None:\n        raise Exception(\"msg was not defined\")\n\n    print(Fore.YELLOW + msg + Style.RESET_ALL)\n</code></pre>"},{"location":"umlet/file/writer/","title":"Writer module","text":""},{"location":"umlet/file/writer/#umlet_utils.umlet.file.writer.Writer","title":"<code>Writer</code>","text":"<p>Class for writing the Umlet .uxf files.</p> Source code in <code>umlet_utils/umlet/file/writer.py</code> <pre><code>class Writer:\n    \"\"\"Class for writing the Umlet .uxf files.\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Constructor for class for writing the Umlet .uxf files.\"\"\"\n        self.outdir = kwargs.get(\"outdir\", None)\n        self.outfile = kwargs.get(\"outfile\", None)\n        self.classes_only_outfile = kwargs.get(\"classes_only_outfile\", None)\n        self.logfile = kwargs.get(\"logfile\", None)\n        self.indir = kwargs.get(\"indir\", None)\n        self.verbose = kwargs.get(\"verbose\", None)\n\n        logging.info(f\"Have instantiated Writer in '{os.path.abspath(__file__)}'\")\n\n    def write_file(self, file_objects: List[Dict[Any, Any]]) -&gt; None:\n        \"\"\"Write the Umlet .uxf file.\n\n        Args:\n            file_objects (list): list of dictionaries containing the following:\n                class_name (str): the name of the class\n                private_attributes_list (list): the list of private attributes declared in the constructor of the class\n                methods_list (list): the list of methods defined in the class\n                imports_list (list): the list of import statements in the class\n        \"\"\"\n        x = X_INITIAL_POSITION\n        y = Y_INITIAL_POSITION\n        w = WIDTH\n        h = HEIGHT\n        zoom_level = ZOOM_LEVEL\n        background_color = BACKGROUND_COLOR\n\n        content = []\n        classes_only_content = []\n\n        content.append('&lt;diagram program=\"umletino\" version=\"15.0.0\"&gt;')\n        content.append(f\"&lt;zoom_level&gt;{zoom_level}&lt;/zoom_level&gt;\")\n\n        classes_only_content.append('&lt;diagram program=\"umletino\" version=\"15.0.0\"&gt;')\n        classes_only_content.append(f\"&lt;zoom_level&gt;{zoom_level}&lt;/zoom_level&gt;\")\n\n        for obj in file_objects:\n            class_name = obj[\"class_name\"]\n            while class_name.endswith(\":\"):\n                class_name = class_name.rstrip(\":\")\n\n            methods_list = obj[\"methods_list\"]\n            imports_list = obj[\"imports_list\"]\n            constants_list = obj[\"constants_list\"]\n            private_attributes_list = obj[\"private_attributes_list\"]\n            logging.info(\n                f\"Here are the '{len(private_attributes_list)} private attributes declared in the constructor of class '{class_name}'\"\n            )\n            for attribute in private_attributes_list:\n                logging.info(attribute)\n\n            logging.info(\n                f\"Here are the '{len(methods_list)}' methods declared in the class '{class_name}'\"\n            )\n            for method in methods_list:\n                logging.info(method)\n\n            content.append(\n                f\"\"\"&lt;element&gt;\n                        &lt;id&gt;UMLClass&lt;/id&gt;\n                        &lt;coordinates&gt;\n                            &lt;x&gt;{x}&lt;/x&gt;\n                            &lt;y&gt;{y}&lt;/y&gt;\n                            &lt;w&gt;{int(CLASSES_WIDTH_MULTIPLIER * len(class_name))}&lt;/w&gt;\n                            &lt;h&gt;{h}&lt;/h&gt;\n                        &lt;/coordinates&gt;\n                        &lt;panel_attributes&gt;bg={background_color}\"\"\"\n            )\n\n            content.append(f\"{class_name}\\n\")\n            content.append(\"--\")\n\n            classes_only_content.append(\n                f\"\"\"&lt;element&gt;\n                        &lt;id&gt;UMLClass&lt;/id&gt;\n                        &lt;coordinates&gt;\n                            &lt;x&gt;{x}&lt;/x&gt;\n                            &lt;y&gt;{y}&lt;/y&gt;\n                            &lt;w&gt;{int(CLASSES_WIDTH_MULTIPLIER * len(class_name))}&lt;/w&gt;\n                            &lt;h&gt;{CLASSES_ONLY_HEIGHT}&lt;/h&gt;\n                        &lt;/coordinates&gt;\n                        &lt;panel_attributes&gt;bg={background_color}\"\"\"\n            )\n\n            classes_only_content.append(f\"{class_name}\\n\")\n            classes_only_content.append(\"--\")\n\n            for attribute in private_attributes_list:\n                content.append(f\"- {attribute}\")\n\n            content.append(\"--\")\n\n            for method in methods_list:\n                if method.startswith(\"_\"):\n                    content.append(f\"- {method}\")\n                else:\n                    content.append(f\"+ {method}\")\n\n            content.append(\"--\")\n\n            if len(imports_list) &gt; 0:\n                content.append(\"// dependencies:\")\n                for import_statement in imports_list:\n                    content.append(f\"// {import_statement}\")\n                content.append(\"\\n\")\n\n                classes_only_content.append(\"// dependencies:\")\n                for import_statement in imports_list:\n                    classes_only_content.append(f\"// {import_statement}\")\n                classes_only_content.append(\"\\n\")\n\n            if len(constants_list) &gt; 0:\n                content.append(\"// constants:\")\n                for constant in constants_list:\n                    content.append(f\"// {constant}\")\n                content.append(\"\\n\")\n\n                classes_only_content.append(\"// constants:\")\n                for constant in constants_list:\n                    classes_only_content.append(f\"// {constant}\")\n                classes_only_content.append(\"\\n\")\n\n            content.append(\n                \"\"\"&lt;/panel_attributes&gt;\n                    &lt;additional_attributes&gt;&lt;/additional_attributes&gt;\n                &lt;/element&gt;\"\"\"\n            )\n\n            classes_only_content.append(\n                \"\"\"&lt;/panel_attributes&gt;\n                    &lt;additional_attributes&gt;&lt;/additional_attributes&gt;\n                &lt;/element&gt;\"\"\"\n            )\n\n            x += X_POSITION_INCREMENT\n            y += Y_POSITION_INCREMENT\n\n        content.append(\"&lt;/diagram&gt;\")\n        classes_only_content.append(\"&lt;/diagram&gt;\")\n\n        self._write_outfile(content)\n        self._write_classes_only_outfile(classes_only_content)\n\n    def _write_outfile(self, content) -&gt; None:\n        with open(self.outfile, \"w\") as of:\n            for line in content:\n                of.write(f\"{line}\\n\")\n\n        logging.info(f\"Wrote file '{self.outfile}'\")\n        print(f\"Wrote file '{self.outfile}'\")\n\n    def _write_classes_only_outfile(self, content) -&gt; None:\n        with open(self.classes_only_outfile, \"w\") as of:\n            for line in content:\n                of.write(f\"{line}\\n\")\n\n        logging.info(f\"Wrote classes only file '{self.classes_only_outfile}'\")\n        print(f\"Wrote classes only file '{self.classes_only_outfile}'\")\n</code></pre>"},{"location":"umlet/file/writer/#umlet_utils.umlet.file.writer.Writer.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Constructor for class for writing the Umlet .uxf files.</p> Source code in <code>umlet_utils/umlet/file/writer.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Constructor for class for writing the Umlet .uxf files.\"\"\"\n    self.outdir = kwargs.get(\"outdir\", None)\n    self.outfile = kwargs.get(\"outfile\", None)\n    self.classes_only_outfile = kwargs.get(\"classes_only_outfile\", None)\n    self.logfile = kwargs.get(\"logfile\", None)\n    self.indir = kwargs.get(\"indir\", None)\n    self.verbose = kwargs.get(\"verbose\", None)\n\n    logging.info(f\"Have instantiated Writer in '{os.path.abspath(__file__)}'\")\n</code></pre>"},{"location":"umlet/file/writer/#umlet_utils.umlet.file.writer.Writer.write_file","title":"<code>write_file(file_objects)</code>","text":"<p>Write the Umlet .uxf file.</p> <p>Parameters:</p> Name Type Description Default <code>file_objects</code> <code>list</code> <p>list of dictionaries containing the following: class_name (str): the name of the class private_attributes_list (list): the list of private attributes declared in the constructor of the class methods_list (list): the list of methods defined in the class imports_list (list): the list of import statements in the class</p> required Source code in <code>umlet_utils/umlet/file/writer.py</code> <pre><code>def write_file(self, file_objects: List[Dict[Any, Any]]) -&gt; None:\n    \"\"\"Write the Umlet .uxf file.\n\n    Args:\n        file_objects (list): list of dictionaries containing the following:\n            class_name (str): the name of the class\n            private_attributes_list (list): the list of private attributes declared in the constructor of the class\n            methods_list (list): the list of methods defined in the class\n            imports_list (list): the list of import statements in the class\n    \"\"\"\n    x = X_INITIAL_POSITION\n    y = Y_INITIAL_POSITION\n    w = WIDTH\n    h = HEIGHT\n    zoom_level = ZOOM_LEVEL\n    background_color = BACKGROUND_COLOR\n\n    content = []\n    classes_only_content = []\n\n    content.append('&lt;diagram program=\"umletino\" version=\"15.0.0\"&gt;')\n    content.append(f\"&lt;zoom_level&gt;{zoom_level}&lt;/zoom_level&gt;\")\n\n    classes_only_content.append('&lt;diagram program=\"umletino\" version=\"15.0.0\"&gt;')\n    classes_only_content.append(f\"&lt;zoom_level&gt;{zoom_level}&lt;/zoom_level&gt;\")\n\n    for obj in file_objects:\n        class_name = obj[\"class_name\"]\n        while class_name.endswith(\":\"):\n            class_name = class_name.rstrip(\":\")\n\n        methods_list = obj[\"methods_list\"]\n        imports_list = obj[\"imports_list\"]\n        constants_list = obj[\"constants_list\"]\n        private_attributes_list = obj[\"private_attributes_list\"]\n        logging.info(\n            f\"Here are the '{len(private_attributes_list)} private attributes declared in the constructor of class '{class_name}'\"\n        )\n        for attribute in private_attributes_list:\n            logging.info(attribute)\n\n        logging.info(\n            f\"Here are the '{len(methods_list)}' methods declared in the class '{class_name}'\"\n        )\n        for method in methods_list:\n            logging.info(method)\n\n        content.append(\n            f\"\"\"&lt;element&gt;\n                    &lt;id&gt;UMLClass&lt;/id&gt;\n                    &lt;coordinates&gt;\n                        &lt;x&gt;{x}&lt;/x&gt;\n                        &lt;y&gt;{y}&lt;/y&gt;\n                        &lt;w&gt;{int(CLASSES_WIDTH_MULTIPLIER * len(class_name))}&lt;/w&gt;\n                        &lt;h&gt;{h}&lt;/h&gt;\n                    &lt;/coordinates&gt;\n                    &lt;panel_attributes&gt;bg={background_color}\"\"\"\n        )\n\n        content.append(f\"{class_name}\\n\")\n        content.append(\"--\")\n\n        classes_only_content.append(\n            f\"\"\"&lt;element&gt;\n                    &lt;id&gt;UMLClass&lt;/id&gt;\n                    &lt;coordinates&gt;\n                        &lt;x&gt;{x}&lt;/x&gt;\n                        &lt;y&gt;{y}&lt;/y&gt;\n                        &lt;w&gt;{int(CLASSES_WIDTH_MULTIPLIER * len(class_name))}&lt;/w&gt;\n                        &lt;h&gt;{CLASSES_ONLY_HEIGHT}&lt;/h&gt;\n                    &lt;/coordinates&gt;\n                    &lt;panel_attributes&gt;bg={background_color}\"\"\"\n        )\n\n        classes_only_content.append(f\"{class_name}\\n\")\n        classes_only_content.append(\"--\")\n\n        for attribute in private_attributes_list:\n            content.append(f\"- {attribute}\")\n\n        content.append(\"--\")\n\n        for method in methods_list:\n            if method.startswith(\"_\"):\n                content.append(f\"- {method}\")\n            else:\n                content.append(f\"+ {method}\")\n\n        content.append(\"--\")\n\n        if len(imports_list) &gt; 0:\n            content.append(\"// dependencies:\")\n            for import_statement in imports_list:\n                content.append(f\"// {import_statement}\")\n            content.append(\"\\n\")\n\n            classes_only_content.append(\"// dependencies:\")\n            for import_statement in imports_list:\n                classes_only_content.append(f\"// {import_statement}\")\n            classes_only_content.append(\"\\n\")\n\n        if len(constants_list) &gt; 0:\n            content.append(\"// constants:\")\n            for constant in constants_list:\n                content.append(f\"// {constant}\")\n            content.append(\"\\n\")\n\n            classes_only_content.append(\"// constants:\")\n            for constant in constants_list:\n                classes_only_content.append(f\"// {constant}\")\n            classes_only_content.append(\"\\n\")\n\n        content.append(\n            \"\"\"&lt;/panel_attributes&gt;\n                &lt;additional_attributes&gt;&lt;/additional_attributes&gt;\n            &lt;/element&gt;\"\"\"\n        )\n\n        classes_only_content.append(\n            \"\"\"&lt;/panel_attributes&gt;\n                &lt;additional_attributes&gt;&lt;/additional_attributes&gt;\n            &lt;/element&gt;\"\"\"\n        )\n\n        x += X_POSITION_INCREMENT\n        y += Y_POSITION_INCREMENT\n\n    content.append(\"&lt;/diagram&gt;\")\n    classes_only_content.append(\"&lt;/diagram&gt;\")\n\n    self._write_outfile(content)\n    self._write_classes_only_outfile(classes_only_content)\n</code></pre>"},{"location":"umlet/file_system/util/","title":"Util module","text":""},{"location":"umlet/file_system/util/#umlet_utils.umlet.file_system.util.Util","title":"<code>Util</code>","text":"<p>Class for working with file system.</p> Source code in <code>umlet_utils/umlet/file_system/util.py</code> <pre><code>class Util:\n    \"\"\"Class for working with file system.\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Constructor for class for working with file system.\"\"\"\n        self.outdir = kwargs.get(\"outdir\", None)\n        self.outfile = kwargs.get(\"outfile\", None)\n        self.logfile = kwargs.get(\"logfile\", None)\n        self.config = kwargs.get(\"config\", None)\n        self.config_file = kwargs.get(\"config_file\", None)\n\n    def get_file_list_from_directory(self, indir: str = None) -&gt; List[str]:\n        \"\"\"Get the list of files in the specified directory.\n\n        :param indir: {str} - the directory to search for files\n        :param extension: {str} - the file extension to filter on\n        :returns file_list: {list} - the list of files found in the directory\n        \"\"\"\n        if not os.path.exists(indir):\n            raise Exception(f\"'{indir}' does not exist\")\n\n        file_list = []\n        for dirpath, _, filenames in os.walk(indir):\n            if \"venv\" in dirpath:\n                # logging.info(f\"Going to ignore files in directory '{dirpath}'\")\n                continue\n            for name in filenames:\n                path = os.path.normpath(os.path.join(dirpath, name))\n                if os.path.isfile(path):\n                    if path.endswith(\".py\"):\n                        file_list.append(path)\n\n        return file_list\n</code></pre>"},{"location":"umlet/file_system/util/#umlet_utils.umlet.file_system.util.Util.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Constructor for class for working with file system.</p> Source code in <code>umlet_utils/umlet/file_system/util.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Constructor for class for working with file system.\"\"\"\n    self.outdir = kwargs.get(\"outdir\", None)\n    self.outfile = kwargs.get(\"outfile\", None)\n    self.logfile = kwargs.get(\"logfile\", None)\n    self.config = kwargs.get(\"config\", None)\n    self.config_file = kwargs.get(\"config_file\", None)\n</code></pre>"},{"location":"umlet/file_system/util/#umlet_utils.umlet.file_system.util.Util.get_file_list_from_directory","title":"<code>get_file_list_from_directory(indir=None)</code>","text":"<p>Get the list of files in the specified directory.</p> <p>:param indir: {str} - the directory to search for files :param extension: {str} - the file extension to filter on :returns file_list: {list} - the list of files found in the directory</p> Source code in <code>umlet_utils/umlet/file_system/util.py</code> <pre><code>def get_file_list_from_directory(self, indir: str = None) -&gt; List[str]:\n    \"\"\"Get the list of files in the specified directory.\n\n    :param indir: {str} - the directory to search for files\n    :param extension: {str} - the file extension to filter on\n    :returns file_list: {list} - the list of files found in the directory\n    \"\"\"\n    if not os.path.exists(indir):\n        raise Exception(f\"'{indir}' does not exist\")\n\n    file_list = []\n    for dirpath, _, filenames in os.walk(indir):\n        if \"venv\" in dirpath:\n            # logging.info(f\"Going to ignore files in directory '{dirpath}'\")\n            continue\n        for name in filenames:\n            path = os.path.normpath(os.path.join(dirpath, name))\n            if os.path.isfile(path):\n                if path.endswith(\".py\"):\n                    file_list.append(path)\n\n    return file_list\n</code></pre>"},{"location":"umlet/python/code_base/surveyor/","title":"Surveyor module","text":""},{"location":"umlet/python/code_base/surveyor/#umlet_utils.umlet.python.code_base.surveyor.Surveyor","title":"<code>Surveyor</code>","text":"<p>Class for converting Python files into Umlet class diagram .uxf file.</p> Source code in <code>umlet_utils/umlet/python/code_base/surveyor.py</code> <pre><code>class Surveyor:\n    \"\"\"Class for converting Python files into Umlet class diagram .uxf file.\"\"\"\n\n    def __init__(self, **kwargs: Dict[str, str]):\n        \"\"\"Class constructor.\"\"\"\n        self.outdir = kwargs.get(\"outdir\", None)\n        self.outfile = kwargs.get(\"outfile\", None)\n        self.logfile = kwargs.get(\"logfile\", None)\n        self.indir = kwargs.get(\"indir\", None)\n        self.verbose = kwargs.get(\"verbose\", DEFAULT_VERBOSE)\n\n        self.util = Util(**kwargs)\n\n        self.class_ctr = 0\n        self.file_ctr = 0\n        self.method_ctr = 0\n        self.imports_set = set()\n        self.constants_set = set()\n\n\n        logging.info(f\"Have instantiated Surveyor in '{os.path.abspath(__file__)}'\")\n\n    def run(self) -&gt; None:\n        \"\"\"Will retrieve the Python files from the specified directory, parse\n        each file and then write the report .txt file.\"\"\"\n        file_list = self.util.get_file_list_from_directory(self.indir)\n\n        file_objects = []\n\n        for python_file in file_list:\n            logging.info(f\"Processing Python file '{python_file}'\")\n            self.file_ctr += 1\n\n            parser = Parser(infile=python_file)\n            class_name = parser.get_class_name()\n            if class_name is None:\n                continue\n\n            self.class_ctr += 1\n            methods = parser.get_methods_list()\n            self.method_ctr += len(methods)\n\n            imports = parser.get_imports_list()\n            for i in imports:\n                self.imports_set.add(i)\n\n            constants = parser.get_constants_list()\n            for c in constants:\n                self.constants_set.add(c)\n\n            lookup = {\n                \"filename\": python_file,\n                \"class_name\": class_name,\n                \"private_attributes_list\": parser.get_private_attributes_list(),\n                \"methods_list\": methods,\n                \"imports_list\": imports,\n                \"constants_list\": constants,\n            }\n\n            file_objects.append(lookup)\n\n        self._write_report_file(file_objects)\n\n\n    def _write_report_file(self, file_objects: Union[Dict[str, Any], None] = None) -&gt; None:\n\n        with open(self.outfile, 'w') as of:\n            of.write(f\"## method-created: {os.path.abspath(__file__)}\\n\")\n            of.write(f\"## date-created: {str(datetime.today().strftime('%Y-%m-%d-%H%M%S'))}\\n\")\n            of.write(f\"## created-by: {os.environ.get('USER')}\\n\")\n            of.write(f\"## indir: {self.indir}\\n\")\n            of.write(f\"## logfile: {self.logfile}\\n\")\n            of.write(\"\\n\\n========================================\\n\\n\")\n            of.write(\"\\t\\tSummary\\n\")\n            of.write(\"\\n\\n========================================\\n\\n\")\n\n            of.write(f\"Number of files: {self.file_ctr}\\n\")\n            of.write(f\"Number of classes: {self.class_ctr}\\n\")\n            of.write(f\"Number of methods: {self.method_ctr}\\n\")\n            of.write(f\"Number of unique imports: {len(self.imports_set)}\\n\")\n            of.write(f\"Number of unique constants: {len(self.constants_set)}\\n\")\n\n            for fo in file_objects:\n                of.write(\"\\n========================================\\n\")\n\n                of.write(f\"For file '{fo['filename']}'\\n\")\n\n                of.write(f\"\\nFound the following '{len(fo['imports_list'])}' imports:\\n\")\n                for i, im in enumerate(fo['imports_list'], start=1):\n                    of.write(f\"{i}. {im}\\n\")\n\n                of.write(f\"\\nFound the following '{len(fo['constants_list'])}' constants:\\n\")\n                for i, c in enumerate(fo['constants_list'], start=1):\n                    of.write(f\"{i}. {c}\\n\")\n\n\n                of.write(f\"\\nFound class '{fo['class_name']}'\\n\")\n\n                of.write(f\"\\nFound the following '{len(fo['private_attributes_list'])}' private attributes:\\n\")\n                for i, pa in enumerate(fo['private_attributes_list'], start=1):\n                    of.write(f\"{i}. {pa}\\n\")\n\n                of.write(f\"\\nFound the following '{len(fo['methods_list'])}' methods:\\n\")\n                for i, m in enumerate(fo['methods_list'], start=1):\n                    of.write(f\"{i}. {m}\\n\")\n\n\n\n        logging.info(f\"Wrote file '{self.outfile}'\")\n        if self.verbose:\n            print(f\"Wrote file '{self.outfile}'\")\n</code></pre>"},{"location":"umlet/python/code_base/surveyor/#umlet_utils.umlet.python.code_base.surveyor.Surveyor.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Class constructor.</p> Source code in <code>umlet_utils/umlet/python/code_base/surveyor.py</code> <pre><code>def __init__(self, **kwargs: Dict[str, str]):\n    \"\"\"Class constructor.\"\"\"\n    self.outdir = kwargs.get(\"outdir\", None)\n    self.outfile = kwargs.get(\"outfile\", None)\n    self.logfile = kwargs.get(\"logfile\", None)\n    self.indir = kwargs.get(\"indir\", None)\n    self.verbose = kwargs.get(\"verbose\", DEFAULT_VERBOSE)\n\n    self.util = Util(**kwargs)\n\n    self.class_ctr = 0\n    self.file_ctr = 0\n    self.method_ctr = 0\n    self.imports_set = set()\n    self.constants_set = set()\n\n\n    logging.info(f\"Have instantiated Surveyor in '{os.path.abspath(__file__)}'\")\n</code></pre>"},{"location":"umlet/python/code_base/surveyor/#umlet_utils.umlet.python.code_base.surveyor.Surveyor.run","title":"<code>run()</code>","text":"<p>Will retrieve the Python files from the specified directory, parse each file and then write the report .txt file.</p> Source code in <code>umlet_utils/umlet/python/code_base/surveyor.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Will retrieve the Python files from the specified directory, parse\n    each file and then write the report .txt file.\"\"\"\n    file_list = self.util.get_file_list_from_directory(self.indir)\n\n    file_objects = []\n\n    for python_file in file_list:\n        logging.info(f\"Processing Python file '{python_file}'\")\n        self.file_ctr += 1\n\n        parser = Parser(infile=python_file)\n        class_name = parser.get_class_name()\n        if class_name is None:\n            continue\n\n        self.class_ctr += 1\n        methods = parser.get_methods_list()\n        self.method_ctr += len(methods)\n\n        imports = parser.get_imports_list()\n        for i in imports:\n            self.imports_set.add(i)\n\n        constants = parser.get_constants_list()\n        for c in constants:\n            self.constants_set.add(c)\n\n        lookup = {\n            \"filename\": python_file,\n            \"class_name\": class_name,\n            \"private_attributes_list\": parser.get_private_attributes_list(),\n            \"methods_list\": methods,\n            \"imports_list\": imports,\n            \"constants_list\": constants,\n        }\n\n        file_objects.append(lookup)\n\n    self._write_report_file(file_objects)\n</code></pre>"},{"location":"umlet/python/file/parser/","title":"Parser module","text":""},{"location":"umlet/python/file/parser/#umlet_utils.umlet.python.file.parser.Parser","title":"<code>Parser</code>","text":"<p>Class for parsing Python .py files.</p> Source code in <code>umlet_utils/umlet/python/file/parser.py</code> <pre><code>class Parser:\n    \"\"\"Class for parsing Python .py files.\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Constructor for class for parsing Python .py files.\"\"\"\n\n        self.infile = kwargs.get(\"infile\", None)\n\n        self.is_parsed = False\n        self.private_attributes_list = []\n        self.uniq_private_attributes_lookup = {}\n        self.class_name = None\n        self.methods_list = []\n        self.imports_list = []\n        self.constants_list = []\n\n        logging.info(f\"Have instantiated Parser in '{os.path.abspath(__file__)}'\")\n\n    def get_private_attributes_list(self) -&gt; None:\n        \"\"\"Retrieve the list of private attributes declared in the constructor\n        of the class.\n\n        Returns:\n            list: list of private attributes\n        \"\"\"\n        if not self.is_parsed:\n            self._parse_file()\n        return self.private_attributes_list\n\n    def get_class_name(self) -&gt; None:\n        \"\"\"Retrieve the name of the class.\n\n        Returns:\n            str: name of the class\n        \"\"\"\n        if not self.is_parsed:\n            self._parse_file()\n        return self.class_name\n\n    def get_methods_list(self) -&gt; None:\n        \"\"\"Retrieve the list of method names defined in the class.\n\n        Returns:\n            list: list of method names\n        \"\"\"\n        if not self.is_parsed:\n            self._parse_file()\n        return self.methods_list\n\n    def get_imports_list(self) -&gt; None:\n        \"\"\"Retrieve the list of import statements for the class.\n\n        Returns:\n            list: list of import statements\n        \"\"\"\n        if not self.is_parsed:\n            self._parse_file()\n        return self.imports_list\n\n    def get_constants_list(self) -&gt; None:\n        \"\"\"Retrieve the list of import statements for the class.\n\n        Returns:\n            list: list of import statements\n        \"\"\"\n        if not self.is_parsed:\n            self._parse_file()\n        return self.constants_list\n\n    def _parse_file(self) -&gt; None:\n        logging.info(f\"Will read file '{self.infile}'\")\n        line_ctr = 0\n\n        class_found = False\n        found_constructor = False\n        processed_constructor = False\n\n        with open(self.infile, \"r\") as f:\n            for line in f:\n                line_ctr += 1\n                line = line.strip()\n                if line == \"\":\n                    continue\n\n                if not class_found:\n                    if line.startswith(\"import \"):\n                        self.imports_list.append(line.strip())\n                    elif line.startswith(\"from \") and \" import \" in line:\n                        self.imports_list.append(line.strip())\n                    elif \"=\" in line:\n                        constant = line.split(\"=\")[0].strip()\n                        self.constants_list.append(constant)\n\n                if line.startswith(\"class \"):\n                    class_found = True\n                    class_name = line.replace(\"class \", \"\")\n                    if \"(\" in class_name:\n                        parts = class_name.split(\"(\")\n                        class_name = parts[0]\n                    if \"src\" in self.infile:\n                        parts = self.infile.split(\"src/\")\n                        prefix = parts[1].replace(\"/\", \"::\")\n                        if prefix.endswith(\".py\"):\n                            prefix = prefix.rstrip(\".py\")\n                        full_class_name = f\"{prefix}::{class_name}\"\n                    else:\n                        full_class_name = class_name\n                    self.class_name = full_class_name\n                elif line.startswith(\"def __init__(self\"):\n                    found_constructor = True\n\n                elif found_constructor and not processed_constructor:\n                    if line.startswith(\"self.\"):\n                        private_attribute = (\n                            line.split(\"=\")[0].replace(\"self.\", \"\").strip()\n                        )\n                        logging.info(\n                            f\"derived private attribute '{private_attribute}' from line '{line}'\"\n                        )\n                        if private_attribute not in self.uniq_private_attributes_lookup:\n                            self.private_attributes_list.append(private_attribute)\n                            self.uniq_private_attributes_lookup[\n                                private_attribute\n                            ] = True\n\n                    elif line.startswith(\"def \"):\n                        processed_constructor = True\n                        found_constructor = False\n\n                        method, method_signature = self._parse_method(line)\n                        # method = line.lstrip(\"def \").split(\"(\")[0]\n                        logging.info(f\"derived method '{method}' from line '{line}'\")\n                        self.methods_list.append(method_signature)\n\n                elif line.startswith(\"def \") and processed_constructor:\n                    method, method_signature = self._parse_method(line)\n                    logging.info(f\"derived method '{method}' from line '{line}'\")\n                    self.methods_list.append(method_signature)\n\n        if line_ctr &gt; 0:\n            logging.info(f\"Read '{line_ctr}' lines from file '{self.infile}'\")\n        else:\n            logging.info(f\"Did not read any lines from file '{self.infile}'\")\n        self.is_parsed = True\n\n    def _parse_method(self, line: str) -&gt; Tuple[str, str]:\n        \"\"\"Parse the method to derive the method name and method signature.\n\n        Args:\n            line (str): the line to parse\n        Returns:\n            str: the method name\n            str: the method signature\n        \"\"\"\n        method_name = line.strip().split(\"(\")[0].lstrip(\"def \")\n        method_signature = line.strip().lstrip(\"def \")\n\n        if \"(self, \" in method_signature:\n            method_signature = method_signature.replace(\"(self, \", \"(\")\n        elif \"(self \" in method_signature:\n            method_signature = method_signature.replace(\"(self \", \"(\")\n\n        method_signature = method_signature.rstrip(\":\") # remove trailing colon\n        return method_name, method_signature\n</code></pre>"},{"location":"umlet/python/file/parser/#umlet_utils.umlet.python.file.parser.Parser.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Constructor for class for parsing Python .py files.</p> Source code in <code>umlet_utils/umlet/python/file/parser.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Constructor for class for parsing Python .py files.\"\"\"\n\n    self.infile = kwargs.get(\"infile\", None)\n\n    self.is_parsed = False\n    self.private_attributes_list = []\n    self.uniq_private_attributes_lookup = {}\n    self.class_name = None\n    self.methods_list = []\n    self.imports_list = []\n    self.constants_list = []\n\n    logging.info(f\"Have instantiated Parser in '{os.path.abspath(__file__)}'\")\n</code></pre>"},{"location":"umlet/python/file/parser/#umlet_utils.umlet.python.file.parser.Parser.get_class_name","title":"<code>get_class_name()</code>","text":"<p>Retrieve the name of the class.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>None</code> <p>name of the class</p> Source code in <code>umlet_utils/umlet/python/file/parser.py</code> <pre><code>def get_class_name(self) -&gt; None:\n    \"\"\"Retrieve the name of the class.\n\n    Returns:\n        str: name of the class\n    \"\"\"\n    if not self.is_parsed:\n        self._parse_file()\n    return self.class_name\n</code></pre>"},{"location":"umlet/python/file/parser/#umlet_utils.umlet.python.file.parser.Parser.get_constants_list","title":"<code>get_constants_list()</code>","text":"<p>Retrieve the list of import statements for the class.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>None</code> <p>list of import statements</p> Source code in <code>umlet_utils/umlet/python/file/parser.py</code> <pre><code>def get_constants_list(self) -&gt; None:\n    \"\"\"Retrieve the list of import statements for the class.\n\n    Returns:\n        list: list of import statements\n    \"\"\"\n    if not self.is_parsed:\n        self._parse_file()\n    return self.constants_list\n</code></pre>"},{"location":"umlet/python/file/parser/#umlet_utils.umlet.python.file.parser.Parser.get_imports_list","title":"<code>get_imports_list()</code>","text":"<p>Retrieve the list of import statements for the class.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>None</code> <p>list of import statements</p> Source code in <code>umlet_utils/umlet/python/file/parser.py</code> <pre><code>def get_imports_list(self) -&gt; None:\n    \"\"\"Retrieve the list of import statements for the class.\n\n    Returns:\n        list: list of import statements\n    \"\"\"\n    if not self.is_parsed:\n        self._parse_file()\n    return self.imports_list\n</code></pre>"},{"location":"umlet/python/file/parser/#umlet_utils.umlet.python.file.parser.Parser.get_methods_list","title":"<code>get_methods_list()</code>","text":"<p>Retrieve the list of method names defined in the class.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>None</code> <p>list of method names</p> Source code in <code>umlet_utils/umlet/python/file/parser.py</code> <pre><code>def get_methods_list(self) -&gt; None:\n    \"\"\"Retrieve the list of method names defined in the class.\n\n    Returns:\n        list: list of method names\n    \"\"\"\n    if not self.is_parsed:\n        self._parse_file()\n    return self.methods_list\n</code></pre>"},{"location":"umlet/python/file/parser/#umlet_utils.umlet.python.file.parser.Parser.get_private_attributes_list","title":"<code>get_private_attributes_list()</code>","text":"<p>Retrieve the list of private attributes declared in the constructor of the class.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>None</code> <p>list of private attributes</p> Source code in <code>umlet_utils/umlet/python/file/parser.py</code> <pre><code>def get_private_attributes_list(self) -&gt; None:\n    \"\"\"Retrieve the list of private attributes declared in the constructor\n    of the class.\n\n    Returns:\n        list: list of private attributes\n    \"\"\"\n    if not self.is_parsed:\n        self._parse_file()\n    return self.private_attributes_list\n</code></pre>"},{"location":"umlet/python_to_umlet/converter/","title":"Converter module","text":""},{"location":"umlet/python_to_umlet/converter/#umlet_utils.umlet.python_to_umlet.converter.Converter","title":"<code>Converter</code>","text":"<p>Class for converting Python files into Umlet class diagram .uxf file.</p> Source code in <code>umlet_utils/umlet/python_to_umlet/converter.py</code> <pre><code>class Converter:\n    \"\"\"Class for converting Python files into Umlet class diagram .uxf file.\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Class constructor.\"\"\"\n        self.outdir = kwargs.get(\"outdir\", None)\n        self.outfile = kwargs.get(\"outfile\", None)\n        self.classes_only_outfile = kwargs.get(\"classes_only_outfile\", None)\n        self.logfile = kwargs.get(\"logfile\", None)\n        self.indir = kwargs.get(\"indir\", None)\n\n        self.util = Util(**kwargs)\n        self.writer = Writer(**kwargs)\n\n        logging.info(f\"Have instantiated Converter in '{os.path.abspath(__file__)}'\")\n\n    def run(self) -&gt; None:\n        \"\"\"Will retrieve the Python files from the specified directory, parse\n        each file and then write the Umlet .uxf file.\"\"\"\n        file_list = self.util.get_file_list_from_directory(self.indir)\n\n        file_objects = []\n\n        for python_file in file_list:\n            logging.info(f\"Processing Python file '{python_file}'\")\n\n            parser = Parser(infile=python_file)\n            class_name = parser.get_class_name()\n            if class_name is None:\n                continue\n\n            lookup = {\n                \"class_name\": class_name,\n                \"private_attributes_list\": parser.get_private_attributes_list(),\n                \"methods_list\": parser.get_methods_list(),\n                \"imports_list\": parser.get_imports_list(),\n                \"constants_list\": parser.get_constants_list(),\n            }\n\n            file_objects.append(lookup)\n\n        self.writer.write_file(file_objects)\n</code></pre>"},{"location":"umlet/python_to_umlet/converter/#umlet_utils.umlet.python_to_umlet.converter.Converter.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Class constructor.</p> Source code in <code>umlet_utils/umlet/python_to_umlet/converter.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Class constructor.\"\"\"\n    self.outdir = kwargs.get(\"outdir\", None)\n    self.outfile = kwargs.get(\"outfile\", None)\n    self.classes_only_outfile = kwargs.get(\"classes_only_outfile\", None)\n    self.logfile = kwargs.get(\"logfile\", None)\n    self.indir = kwargs.get(\"indir\", None)\n\n    self.util = Util(**kwargs)\n    self.writer = Writer(**kwargs)\n\n    logging.info(f\"Have instantiated Converter in '{os.path.abspath(__file__)}'\")\n</code></pre>"},{"location":"umlet/python_to_umlet/converter/#umlet_utils.umlet.python_to_umlet.converter.Converter.run","title":"<code>run()</code>","text":"<p>Will retrieve the Python files from the specified directory, parse each file and then write the Umlet .uxf file.</p> Source code in <code>umlet_utils/umlet/python_to_umlet/converter.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Will retrieve the Python files from the specified directory, parse\n    each file and then write the Umlet .uxf file.\"\"\"\n    file_list = self.util.get_file_list_from_directory(self.indir)\n\n    file_objects = []\n\n    for python_file in file_list:\n        logging.info(f\"Processing Python file '{python_file}'\")\n\n        parser = Parser(infile=python_file)\n        class_name = parser.get_class_name()\n        if class_name is None:\n            continue\n\n        lookup = {\n            \"class_name\": class_name,\n            \"private_attributes_list\": parser.get_private_attributes_list(),\n            \"methods_list\": parser.get_methods_list(),\n            \"imports_list\": parser.get_imports_list(),\n            \"constants_list\": parser.get_constants_list(),\n        }\n\n        file_objects.append(lookup)\n\n    self.writer.write_file(file_objects)\n</code></pre>"},{"location":"umlet/use_case/file/writer/","title":"Writer module","text":""},{"location":"umlet/use_case/file/writer/#umlet_utils.umlet.use_case.file.writer.Writer","title":"<code>Writer</code>","text":"<p>Class for writing the Umlet .uxf files.</p> Source code in <code>umlet_utils/umlet/use_case/file/writer.py</code> <pre><code>class Writer:\n    \"\"\"Class for writing the Umlet .uxf files.\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Constructor for class for writing the Umlet .uxf files.\"\"\"\n        self.outdir = kwargs.get(\"outdir\", None)\n        self.outfile = kwargs.get(\"outfile\", None)\n        self.classes_only_outfile = kwargs.get(\"classes_only_outfile\", None)\n        self.logfile = kwargs.get(\"logfile\", None)\n        self.indir = kwargs.get(\"indir\", None)\n        self.verbose = kwargs.get(\"verbose\", None)\n        self.content = []\n\n        self.x = X_INITIAL_POSITION\n        self.y = Y_INITIAL_POSITION\n        self.w = WIDTH\n        self.h = HEIGHT\n        self.zoom_level = ZOOM_LEVEL\n        self.background_color = BACKGROUND_COLOR\n\n        logging.info(f\"Have instantiated Writer in '{os.path.abspath(__file__)}'\")\n\n    def write_file(self, cases: List[str], actors: List[str]) -&gt; None:\n        \"\"\"Write the Umlet .uxf file.\n\n        Args:\n            cases (list): list of use cases\n            actors (list): list of actors\n        \"\"\"\n        self.content.append('&lt;diagram program=\"umletino\" version=\"15.0.0\"&gt;')\n        self.content.append(f\"&lt;zoom_level&gt;{self.zoom_level}&lt;/zoom_level&gt;\")\n        self.add_cases(cases)\n        self.add_actors(actors)\n        self.content.append(\"&lt;/diagram&gt;\")\n        self._write_outfile()\n\n    def add_cases(self, cases: List[str]) -&gt; None:\n        for case in cases:\n            self.content.append(\n                f\"\"\"&lt;element&gt;\n                        &lt;id&gt;UMLUseCase&lt;/id&gt;\n                        &lt;coordinates&gt;\n                            &lt;x&gt;{self.x}&lt;/x&gt;\n                            &lt;y&gt;{self.y}&lt;/y&gt;\n                            &lt;w&gt;{self.w}&lt;/w&gt;\n                            &lt;h&gt;{self.h}&lt;/h&gt;\n                        &lt;/coordinates&gt;\n                        &lt;panel_attributes&gt;bg={self.background_color}\n{case}\n                        &lt;/panel_attributes&gt;\n                        &lt;additional_attributes&gt;&lt;/additional_attributes&gt;\n                    &lt;/element&gt;\n                    \"\"\"\n            )\n\n            self.x += X_POSITION_INCREMENT\n            self.y += Y_POSITION_INCREMENT\n\n    def add_actors(self, actors: List[str]) -&gt; None:\n        for actor in actors:\n            self.content.append(\n                f\"\"\"&lt;element&gt;\n                        &lt;id&gt;UMLActor&lt;/id&gt;\n                        &lt;coordinates&gt;\n                            &lt;x&gt;{self.x}&lt;/x&gt;\n                            &lt;y&gt;{self.y}&lt;/y&gt;\n                            &lt;w&gt;{self.w}&lt;/w&gt;\n                            &lt;h&gt;{self.h}&lt;/h&gt;\n                        &lt;/coordinates&gt;\n                        &lt;panel_attributes&gt;bg={self.background_color}\n                        {actor}\n                        &lt;/panel_attributes&gt;\n                        &lt;additional_attributes&gt;&lt;/additional_attributes&gt;\n                    &lt;/element&gt;\n                    \"\"\"\n            )\n\n            self.x += X_POSITION_INCREMENT\n            self.y += Y_POSITION_INCREMENT\n\n    def _write_outfile(self) -&gt; None:\n        with open(self.outfile, \"w\") as of:\n            for line in self.content:\n                of.write(f\"{line}\\n\")\n\n        logging.info(f\"Wrote file '{self.outfile}'\")\n        print(f\"Wrote file '{self.outfile}'\")\n</code></pre>"},{"location":"umlet/use_case/file/writer/#umlet_utils.umlet.use_case.file.writer.Writer.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Constructor for class for writing the Umlet .uxf files.</p> Source code in <code>umlet_utils/umlet/use_case/file/writer.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Constructor for class for writing the Umlet .uxf files.\"\"\"\n    self.outdir = kwargs.get(\"outdir\", None)\n    self.outfile = kwargs.get(\"outfile\", None)\n    self.classes_only_outfile = kwargs.get(\"classes_only_outfile\", None)\n    self.logfile = kwargs.get(\"logfile\", None)\n    self.indir = kwargs.get(\"indir\", None)\n    self.verbose = kwargs.get(\"verbose\", None)\n    self.content = []\n\n    self.x = X_INITIAL_POSITION\n    self.y = Y_INITIAL_POSITION\n    self.w = WIDTH\n    self.h = HEIGHT\n    self.zoom_level = ZOOM_LEVEL\n    self.background_color = BACKGROUND_COLOR\n\n    logging.info(f\"Have instantiated Writer in '{os.path.abspath(__file__)}'\")\n</code></pre>"},{"location":"umlet/use_case/file/writer/#umlet_utils.umlet.use_case.file.writer.Writer.write_file","title":"<code>write_file(cases, actors)</code>","text":"<p>Write the Umlet .uxf file.</p> <p>Parameters:</p> Name Type Description Default <code>cases</code> <code>list</code> <p>list of use cases</p> required <code>actors</code> <code>list</code> <p>list of actors</p> required Source code in <code>umlet_utils/umlet/use_case/file/writer.py</code> <pre><code>def write_file(self, cases: List[str], actors: List[str]) -&gt; None:\n    \"\"\"Write the Umlet .uxf file.\n\n    Args:\n        cases (list): list of use cases\n        actors (list): list of actors\n    \"\"\"\n    self.content.append('&lt;diagram program=\"umletino\" version=\"15.0.0\"&gt;')\n    self.content.append(f\"&lt;zoom_level&gt;{self.zoom_level}&lt;/zoom_level&gt;\")\n    self.add_cases(cases)\n    self.add_actors(actors)\n    self.content.append(\"&lt;/diagram&gt;\")\n    self._write_outfile()\n</code></pre>"},{"location":"umlet/yaml_to_umlet/use_case/converter/","title":"Converter module","text":""},{"location":"umlet/yaml_to_umlet/use_case/converter/#umlet_utils.umlet.yaml_to_umlet.use_case.converter.Converter","title":"<code>Converter</code>","text":"<p>Class for converting Python files into Umlet class diagram .uxf file.</p> Source code in <code>umlet_utils/umlet/yaml_to_umlet/use_case/converter.py</code> <pre><code>class Converter:\n    \"\"\"Class for converting Python files into Umlet class diagram .uxf file.\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Class constructor.\"\"\"\n        self.outdir = kwargs.get(\"outdir\", None)\n        self.outfile = kwargs.get(\"outfile\", None)\n        self.classes_only_outfile = kwargs.get(\"classes_only_outfile\", None)\n        self.logfile = kwargs.get(\"logfile\", None)\n        self.infile = kwargs.get(\"infile\", None)\n\n        self.writer = Writer(**kwargs)\n\n        logging.info(f\"Have instantiated Converter in '{os.path.abspath(__file__)}'\")\n\n    def run(self) -&gt; None:\n        \"\"\"Will retrieve list of use cases and actors from the config file and write the Umlet .uxf file.\"\"\"\n        config = yaml.safe_load(pathlib.Path(self.infile).read_text())\n\n        if \"use_cases\" not in config:\n            raise Exception(f\"Did not find 'use_cases' section in file '{self.infile}'\")\n        if \"actors\" not in config:\n            raise Exception(f\"Did not find 'actors' section in file '{self.infile}'\")\n        self.writer.write_file(cases=config[\"use_cases\"], actors=config[\"actors\"])\n</code></pre>"},{"location":"umlet/yaml_to_umlet/use_case/converter/#umlet_utils.umlet.yaml_to_umlet.use_case.converter.Converter.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Class constructor.</p> Source code in <code>umlet_utils/umlet/yaml_to_umlet/use_case/converter.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Class constructor.\"\"\"\n    self.outdir = kwargs.get(\"outdir\", None)\n    self.outfile = kwargs.get(\"outfile\", None)\n    self.classes_only_outfile = kwargs.get(\"classes_only_outfile\", None)\n    self.logfile = kwargs.get(\"logfile\", None)\n    self.infile = kwargs.get(\"infile\", None)\n\n    self.writer = Writer(**kwargs)\n\n    logging.info(f\"Have instantiated Converter in '{os.path.abspath(__file__)}'\")\n</code></pre>"},{"location":"umlet/yaml_to_umlet/use_case/converter/#umlet_utils.umlet.yaml_to_umlet.use_case.converter.Converter.run","title":"<code>run()</code>","text":"<p>Will retrieve list of use cases and actors from the config file and write the Umlet .uxf file.</p> Source code in <code>umlet_utils/umlet/yaml_to_umlet/use_case/converter.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Will retrieve list of use cases and actors from the config file and write the Umlet .uxf file.\"\"\"\n    config = yaml.safe_load(pathlib.Path(self.infile).read_text())\n\n    if \"use_cases\" not in config:\n        raise Exception(f\"Did not find 'use_cases' section in file '{self.infile}'\")\n    if \"actors\" not in config:\n        raise Exception(f\"Did not find 'actors' section in file '{self.infile}'\")\n    self.writer.write_file(cases=config[\"use_cases\"], actors=config[\"actors\"])\n</code></pre>"}]}